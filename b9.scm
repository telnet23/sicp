"problem 1."
(define (new-car id arrive)
  (let ((start '())
        (finish '()))
    (define (set-start t) (set! start t))
    (define (set-finish t) (set! finish t))
    (define (get-wait-time) (- start arrive))
    (define (get-total-time) (- finish arrive))
    (define (get-id) id)
    (lambda (method)
      (cond ((eq? method 'set-start) set-start)
            ((eq? method 'set-finish) set-finish)
            ((eq? method 'get-wait) get-wait-time)
            ((eq? method 'get-total) get-total-time)
            ((eq? method 'get-id) get-id)))))

"problem 2."
(define (make-event t e c)
  (define (get-time) t)
  (define (get-type) e)
  (define (get-car) c)
  (lambda (method)
    (cond ((eq? method 'time) get-time)
          ((eq? method 'type) get-type)
          ((eq? method 'car) get-car))))

"problem 3."
(define (prng seed min max)
  (let ((x seed)
        (a (expt 7 5))
        (c 0)
        (m (- (expt 2 31) 1)))
    (define (next)
      (set! x (modulo (+ (* a x) c) m))
      (get))
    (define (get)
      (+ (modulo x (- max min)) min))
    (lambda (method)
      (cond ((eq? method 'next) next)
            ((eq? method 'get) get)))))

"problem 4."
(define (make-stack)
  (let ((stack '()))
    (define (empty?)
      (null? stack))
    (define (push element)
      (set! stack (cons element stack)))
    (define (top)
      (car stack))
    (define (pop)
      (let ((first (car stack)))
        (set! stack (cdr stack))
        first))
    (lambda (method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'push) push)
            ((eq? method 'top) top)
            ((eq? method 'pop) pop)))))

"problem 5."
(define (eval-postfix p)
  (let ((stack (make-stack)))
    (define (iterate l)
      (cond ((null? l)
             ((stack 'pop)))
            ((number? (car l))
             (let ((operand (car l)))
               ((stack 'push) operand)
               (iterate (cdr l))))
            (else
             (let ((operand2 ((stack 'pop)))
                   (operand1 ((stack 'pop)))
                   (operator (cond ((eq? (car l) #\+) +)
                                   ((eq? (car l) #\-) -)
                                   ((eq? (car l) #\*) *)
                                   ((eq? (car l) #\/) /)
                                   ((eq? (car l) #\^) expt))))
                   ((stack 'push) (operator operand1 operand2))
                   (iterate (cdr l))))))
    (iterate p)))

"problem 6."
(define (make-queue)
  (let ((head '())
        (tail '()))
    (define (empty?) (null? head))
    (define (enqueue x)
      (let ((last (cons x '())))
        (begin
          (if (null? head)
              (set! head last)
              (set-cdr! tail last))
          (set! tail last))))
    (define (dequeue)
      (if (null? head)
          "queue is empty!"
          (let ((first (car head)))
            (if (null? (cdr head)) ; if the queue has only one element
                (begin (set! head '())
                       (set! tail '()))
                (set! head (cdr head)))
            first)))
    (lambda (method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'enqueue) enqueue)
            ((eq? method 'dequeue) dequeue)))))

"problem 7."
(define (make-heap-pqueue lt?)
  (let ((q '())
        (q-size 0))
    (define (make-heap h-min left right) (list h-min left right))
    (define (h-min h) (car h))
    (define (left h) (cadr h))
    (define (right h) (caddr h))
    (define (h-combine h1 h2)
      (cond ((null? h1) h2)
            ((null? h2) h1)
            ((lt? (h-min h1) (h-min h2))
             (make-heap (h-min h1)
                        h2
                        (h-combine (left h1) (right h1))))
            (else
             (make-heap (h-min h2)
                        h1
                        (h-combine (left h2) (right h2))))))
    (define (h-insert x h)
      (cond ((null? h) (make-heap x
                                  (list)
                                  (list)))
            ((equal? x (h-min h)) h)
            ((lt? x (h-min h)) (make-heap x
                                          (right h)
                                          (h-insert (h-min h) (left h))))
            (else (make-heap (h-min h)
                             (right h)
                             (h-insert x (left h))))))
    (define (h-remove-min h)
      (h-combine (left h) (right h)))
    (define (method-empty)
      (null? q))
    (define (method-insert x)
      (set! q (h-insert x q))
      (set! q-size (+ q-size 1)))
    (define (method-size)
      q-size)
    (define (method-extract-min)
      (if (null? q)
          "queue is empty!"
          (let ((return (h-min q)))
            (set! q (h-remove-min q))
            (set! q-size (- q-size 1))
            return)))
    (lambda (method)
      (cond ((eq? method 'empty) method-empty)
            ((eq? method 'insert) method-insert)
            ((eq? method 'size) method-size)
            ((eq? method 'extract-min) method-extract-min)))))

"problem 8. (a)"
(define arrival-times (prng 99 20 40))
(define service-times (prng 1729 25 35))
(define car-q (make-queue))
(define event-q (make-heap-pqueue (lambda (e1 e2)
                                    (< ((e1 'time))
                                       ((e2 'time))))))
(define done '())
(define bay '())
(define (process-event e)
  (cond ((and (equal? ((e 'type)) 'arrival)
              (< ((e 'time)) 900))
         (let ((next-arrival-time (+ ((e 'time)) ((arrival-times 'next))))
               (next-arrival-id (+ ((((e 'car)) 'get-id)) 1)))
           ((event-q 'insert)
            (make-event next-arrival-time
                        'arrival
                        (new-car next-arrival-id next-arrival-time))))
         (if (null? bay)
             (begin
               (set! bay ((e 'car)))
               ((((e 'car)) 'set-start) ((e 'time))))
             (begin
               ((car-q 'enqueue) ((e 'car)))
               ((event-q 'insert)
                (make-event (+ ((e 'time)) ((service-times 'get)))
                            'finish
                            ((e 'car))))
               ((service-times 'next)))))
        ((equal? ((e 'type)) 'finish)
         (set! done (cons ((e 'car)) done))
         ((((e 'car)) 'set-finish) ((e 'time)))
         (if ((car-q 'empty?))
             (set! bay '())
             (let ((next-car ((car-q 'dequeue))))
               (set! bay next-car)
               ((next-car 'set-start) ((e 'time)))
               ((event-q 'insert)
                (make-event (+ ((e 'time)) ((service-times 'get)))
                            'finish
                            next-car))
               ((service-times 'next)))))
        (else '())))

"problem 8. (b)"
(let ((first-arrival-time ((arrival-times 'get))))
  ((event-q 'insert) (make-event first-arrival-time
                                 'arrival
                                 (new-car 0 first-arrival-time))))
(define (sim)
  (if ((event-q 'empty))
      "simulation complete"
      (begin
        (process-event ((event-q 'extract-min)))
        (sim))))

"problem 8. (c)"
(define (avg-wait-time)
  (sim)
  (/ (apply + (map (lambda (car) ((car 'get-wait))) done))
     (length done)))
(define (avg-total-time)
  (sim)
  (/ (apply + (map (lambda (car) ((car 'get-total))) done))
     (length done)))